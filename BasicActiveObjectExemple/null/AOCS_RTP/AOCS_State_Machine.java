// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package AOCS_RTP;

import java.util.concurrent.ScheduledExecutorService;

// Manual imports
import AOCS_RTP.AOCS_Process_Shell.GDEF_STATUS;
import java.util.HashMap;
// End of manual imports

/************************************************************/
/**
 * 
 */
class AOCS_State_Machine {
	/**
	 * 
	 */
	public enum AOCS_MODES {
		/**
		 * 
		 */
		SBM,
		/**
		 * 
		 */
		DTM,
		/**
		 * 
		 */
		YTM,
		/**
		 * 
		 */
		CPM,
		/**
		 * 
		 */
		NOM;
	};

	/**
	 * 
	 */
	public enum AOCS_TRANS_STATE {
		/**
		 * no transition occurring
		 */
		AMOH_TRANS_IDLE,
		/**
		 * transition requested 
		 */
		AMOH_TRANS_REQ,
		/**
		 * hardware configuration
		 */
		AMOH_TRANS_CONFIG,
		/**
		 * set shell parameters
		 */
		AMOH_TRANS_SHELL,
		/**
		 * set algorithm parameters
		 */
		AMOH_TRANS_ALGS;
	};

	/**
	 * This enum defines the possible states of the AOCS shell FSM
	 */
	public enum AOCS_shell_fsm_state {
		/**
		 * AOCS Shell Idle State 
		  * The inactive state where the shell awaits events
		 */
		IDLE,
		/**
		 * AOCS Shell All Pulses Received-check TLM State
		  * State where all Pulse Per Second (PPS) signals are received, and telemetry checks are likely performed
		 */
		TLMR,
		/**
		 * AOCS Shell Run AOCS cycle State
		  * State where the AOCS cycle is running
		 */
		RUNA;
	};

	/**
	 * This enum defines the events that can trigger state transitions in the FSM
	 */
	public enum AOCS_shell_fsm_event {
		/**
		 * Event triggered when a PPS signal is received
		 */
		PPS_RECEIVED,
		/**
		 * Event triggered when all expected PPS signals are received
		 */
		ALL_PPS_RECEIVED,
		/**
		 * Event triggered when a message from AOCS instructs the shell to start the AOCS cycle.
		 */
		AOCS_MESSAGE,
		/**
		 * Issue Actuate command Event
		 */
		ACTUATE;
	};

	/**
	 * 
	 */
	public class AOCS_shell_configuration {
		/**
		 * Firewall Pattern to help detect Memory Corruption
		 */
		public int firewall_head;
		/**
		 * AOCS Shell Protection Mutex 
		 */
		public Thread aocs_shell_protection_mutex;
		/**
		 * AOCS Shell FSM State   
		 */
		public AOCS_shell_fsm_state aocs_shell_fsm_state;
		/**
		 * AOCS Shell FSM Event
		 */
		public AOCS_shell_fsm_event aocs_shell_fsm_event;
		/**
		 * AOCS Shell FSM Event Action Time 
		 */
		public long aocs_shell_event_action_time;
		/**
		 * the AOCS PPS Timer
		 */
		public ScheduledExecutorService aocs_shell_pps_timer_id;
		/**
		 * AOCS Shell PPS Timer
		 */
		public long aocs_shell_pps_timer = 1000;
		/**
		 * AOCS Actuation Timer
		 */
		public ScheduledExecutorService aocs_shell_actuation_timer_id;
		/**
		 * AOCS Shell Actuation Timer
		 */
		public long aocs_shell_actuation_timer = 1000;
		/**
		 * AOCS Shell AIM Check Timer ID
		 */
		public ScheduledExecutorService aocs_shell_aim_check_timer_id;
		/**
		 * AOCS Shell AIM Check Timer
		 */
		public long aocs_shell_aim_check_timer = 1000;
	};

	/**
	 * Current mode
	 */
	private AOCS_MODES AOCS_currentMode = AOCS_MODES.SBM;
	/**
	 * store the requested mode before a transition
	 */
	private AOCS_MODES AOCS_reqMode;
	/**
	 * Store the transition state (if idle next mode)
	 */
	public AOCS_TRANS_STATE AOCS_transState;
	/**
	 * flag to indicate if this is a safe mode
	 */
	public boolean AOCS_isSafeMode;
	/**
	 * Set the requested mode if it is a valid transition
	 */
	public boolean[][] AOCS_modeTransitionTable = new boolean[][] {
			// SBM-----DTM---YTM----CPM----NOM-- : new/old
			{ false, true, false, false, false }, // SBM
			{ true, false, false, false, false }, // DTM
			{ false, false, false, true, false }, // YTM
			{ false, false, false, false, true }, // CPM
			{ false, false, false, false, false } // NOM
	};
	/**
	 * 
	 */
	private StateThread statethread;
	/**
	 * return the AOCS period
	 */
	public int AOCS_maxCycle;
	/**
	 * 
	 */
	public static ALGS_Interface algs_interface;
	/**
	 * 
	 */
	public boolean AOCS_isUnsolMode;
	/**
	 * 
	 */
	public static HW_Manager hw_Manager;
	/**
	 * 
	 */
	public ARO_Handler aro_Handler;
	/**
	 * 
	 */
	public AOCS_Configuration aocs_Configuration;
	/**
	 * Tells is that the current mode has a safe mode version 
	 */
	public boolean[] NUM_SAFE_MODES;
	/**
	 * Tell if we have safe modes for each one of the AOCS modes
	 */
	public boolean SAFE_MODES = false;
	/**
	 * This 2D array defines the next state for each combination of event and current state. 
	  *     * Rows represent events (e.g., PPS_RECEIVED).
	  *     * Columns represent current states (e.g., IDLE).
	 */
	public static AOCS_shell_fsm_state[][] AOCS_shell_state_table = new AOCS_shell_fsm_state[][] {
			/*
			 * RUNAOCS -----------------------------------------------------------------
			 * CHECKTLM ----------------------------------------      					|
			 * IDLE-----------------     		  				|      					|
			 *                      |        	  				|						|
			 *                      |     		  				|     					|
			 */
			{ AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE }, // PPS_RECEIVED    
			{ AOCS_shell_fsm_state.TLMR, AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE }, //ALL_PPS_RECEIVED 
			{ AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.RUNA, AOCS_shell_fsm_state.IDLE }, // ADCS_MESSAGE 
			{ AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE }// ACTUATE
	};
	/**
	 * This 2D array defines functions associated with each event-state combination. Similar to the state transition table:
	  *     * Rows represent events.
	  *     * Columns represent current states.
	 */
	public static AOCS_Shell_EventHandler[][] AOCS_shell_event_table = new AOCS_Shell_EventHandler[][] {
			/*
			 * RUNAOCS ---------------------------------
			 * CHECKTLM --------------------------      |
			 * IDLE-----------------     		  |     |
			 *                      |        	  |		|
			 *                      |     		  |     |
			 */
			{ AOCS_State_Machine::pps_received, null, null }, /* PPS_RECEIVED           */
			{ AOCS_State_Machine::all_pps_received, null, null }, /* ALL_PPS_RECEIVED       */
			{ null, AOCS_State_Machine::run_AOCS, null }, /* ADCS_MESSAGE           */
			{ null, null, AOCS_State_Machine::actuate }/* ACTUATE                */
	};
	/**
	 * Counter on the number of PPS until declaring ALL-PPS-RECEIVED
	 */
	public static int No_of_PPS_sent;
	/**
	 * Default number of pps cycle before all pps_received event
	 */
	public static int AOCS_DEFAULT_CYCLE_TIME = 4;
	/**
	 * to synch time every 1/4 sec
	 */
	public static int No_all_PPS_received;
	/**
	 * When we are here for the "SEND_SYNC_TIME"th is 15*4 = 60sec
	 */
	public static int SEND_SYNC_TIME = 15;
	/**
	 * Counter of pps received by AIM
	 */
	public static int AIM_PPS;
	/**
	 * Constant on the number off pps received by AIM
	 */
	public static int wake_up_aim = 100;

	/**
	 * check if the mode transition is valid then start the updateMode transitions routine
	 * @param newMode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Process_Shell.GDEF_STATUS AOCS_RequestMode(AOCS_MODES newMode) {
		/* check if already performing a mode transistion */
		if (AOCS_transState != AOCS_TRANS_STATE.AMOH_TRANS_IDLE) {
			System.out
					.println("Unable to process mode trans req: [" + AOCS_currentMode + "] -> [" + AOCS_reqMode + "]");
			return GDEF_STATUS.GDEF_FAILURE;
		}
		/* check if is different to current value */
		if (newMode != AOCS_currentMode) {
			/* Set the requested mode if it is a valid transistion */
			if (GDEF_STATUS.GDEF_TRUE == CheckValidModetransition(newMode)) {

				/* set the request mode */
				AOCS_reqMode = newMode;

				/* set the transition state to requested */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_REQ;

				// AOCS Algs will see the flag change and proceeds with mode transition
				AOCS_UpdateMode();
				// print into the ewod
				System.out.println("VALID mode trans req: [" + AOCS_currentMode + "] -> [" + AOCS_reqMode + "]");
			}
		}
		return GDEF_STATUS.GDEF_SUCCESS;
	}

	/**
	 * sets the mode regardless of requests or valid transitions
	 * @param newMode 
	 */
	public void AOCS_ForceMode(AOCS_MODES newMode) {
		/* if current mode transition occurring then abort */
		// ACON_AbortSked(); // not in our case

		// print into the ewod
		System.out.println("Force Mode change to" + AOCS_reqMode);

		//other mode so update in usual manner
		AOCS_reqMode = newMode;
		AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_REQ;
		AOCS_UpdateMode();
	}

	/**
	 * Allow a mode change for new cycle
	 */
	public void AOCS_UpdateMode() {
		// switch the current transition state
		switch (AOCS_transState) {
		case AMOH_TRANS_IDLE:
			/* nothing to do so just return */
			break;

		case AMOH_TRANS_REQ: {
			/*
			 * no config required in standby OPS, config might be required in safe standby
			 * (i.e. logging telemetry)
			 */
			if ((AOCS_MODES.SBM == AOCS_reqMode) && (AOCS_isSafeMode == false)) {
				// update ewod
				// EWOD_SetDefaultTlmType(MODE_SBM);
				/* standby mode so just update shell params */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_SHELL;
			} else {
				/* kick off the hardware config sked for the mode */
				if (GDEF_STATUS.GDEF_SUCCESS != aocs_Configuration.ACON_StartSked(AOCS_reqMode.ordinal())) {
					// failure
					/* abort and go Back */
					AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_IDLE;
					// log to ewod
					System.out.println("Unable to run config sked for mode [" + AOCS_reqMode + "]");
				} else {
					// success
					/* update state to config */
					AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_CONFIG;
					// log to ewod
					System.out.println("config started for mode [" + AOCS_reqMode + "]");
				}
			}
			break;

		}
		case AMOH_TRANS_CONFIG: {
			// check configuration sked complete
			if (!aocs_Configuration.ACON_GetSkedStatus()) {
				// log to ewod
				System.out.println("Config sked completed for mode [" + AOCS_reqMode + "]");
				/* update state to shell */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_SHELL;
			}
			break;
		}
		case AMOH_TRANS_SHELL: {
			/* set shell parameters */
			Set_Shell_AocsMode();

			/* set init flag for algs */
			algs_interface.algs_Struct.mode_isReset = true;
			algs_interface.algs_Struct.mode_current = AOCS_currentMode;
			algs_interface.algs_Struct.mode_isSafeMode = AOCS_isSafeMode;
			algs_interface.algs_Struct.mode_isUnsolicited = AOCS_isUnsolMode;

			// log to ewod
			System.out.println("Shell updated to mode [" + AOCS_reqMode + "]");

			/* update state to ALGS */
			AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_ALGS;
			/* fall through to trans algs immediately */
			break;
		}
		case AMOH_TRANS_ALGS: {

			if (algs_interface.algs_Struct.mode_isReset == false) {
				// log to ewod
				System.out.println("Transition completed to mode [" + AOCS_reqMode + "]");

				/* update state to idle */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_IDLE;
			}

			break;
		}
		default: {
			/* Invalid trans state*/
			System.out.println("Invalid trans state [" + AOCS_reqMode + "]");

			/* update state to idle */
			AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_IDLE;
			break;
		}

		}
	}

	/**
	 * get requested mode number
	 * @return 
	 */
	public AOCS_MODES AOCS_GetReqMode() {
		return AOCS_reqMode;
	}

	/**
	 * Sets the AOCS period
	 * @param period 
	 */
	public void AOCS_SetPeriod(int period) {
		AOCS_maxCycle = period;
	}

	/**
	 *  Calls the AOCS function, checks for errors, and implements the ARO counter.
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int run_AOCS(AOCS_shell_configuration config) {
		/*
		 * When we are here for the "SEND_SYNC_TIME"th, ie 15*4 = 60sec
		 * send sync message to Node 0.
		 */
		/* If we haven't received an ACK for all commands, set the ARO counter */
		if (HW_Manager.HMGR_CheckNoAckErrors() != true) {
			ARO_Handler.ARO_SetDecFlag();
		}

		No_all_PPS_received++;
		AIM_PPS++;
		if (No_all_PPS_received >= SEND_SYNC_TIME) {

			/*
			 * Build and send the sync Telecommand(5,1) to AIM1
			 */
			/*
			CANS_datagram.u1Src    = CANADDR_ADCS_PROCESS;
			CANS_datagram.u1Dest   = CANADDR_BROADCAST;
			CANS_datagram.u1Length = sizeof(CANS_datagram.a1Buffer);
			CANS_datagram.u1Type   = CANI_Time_Set_Command;
			*/
			/*
			  * Distribute the current OBC Time over the Spacecraft CANBUS.
			  * Transmit the Time Synchronisation CAN Datagram over the Spacecraft CANBUS
			  */
			AOCS_Process_Shell.aocs_TTC.CANA_send_datagram(AOCS_Process_Shell.aocs_TTC.cans_datagram);

			//reset the counter 
			No_all_PPS_received = 0;

		}
		if (AIM_PPS >= wake_up_aim) {
			/*        
			  stTcReqParams.psRegInfo      = (tsCANS_RegRtn*)getCANReg();
			  stTcReqParams.eSendQPriority = eCANS_LO_PRI_Q;
			  stTcReqParams.eWait          = eCANS_NO_WAIT;
			  stTcReqParams.u1Src          = CANADDR_ADCS_PROCESS;
			  stTcReqParams.u4RetryCount   = DEFAULT_AOCS_TC_RETRY_COUNT;
			  stTcReqParams.u4RtnQIdx      = DEFAULT_DISPATCHER_Q;
			  stTcReqParams.u4Timeout      = DEFAULT_TELECOMMAND_REQUEST_TIMEOUT;
			  */
			/*
			 * Build and send the sync Telecommand(5,1) to AIM1
			 */
			AOCS_Process_Shell.aocs_TTC.CANA_send_datagram(AOCS_Process_Shell.aocs_TTC.cans_datagram);
			//reset counter
			AIM_PPS = 0;
		}

		/* prepare data for algorithms */
		HW_Manager.HMGR_PrepareData();

		/* RUN THE AOCS ALGORITHMS */
		algs_interface.AINT_AlgManager();

		/*
		* Initialise data gathering for new cycle
		*/
		AOCS_Process_Shell.InitAocs();

		/*
		* Start the 200ms delay before we fire the actuator, as requested by AOCS.
		*/
		// set the new event
		config.aocs_shell_fsm_event = AOCS_shell_fsm_event.ACTUATE;

		// process end execute the new event
		AOCS_Process_Shell.AOCS_Shell_deliver_event(config);

		return 0;
	}

	/**
	 *  Sends the commands to the actuators and updates the AOCS ewods. (HMGR_Actuate)
	  * This function converts the data provided by the AOCS algorithms  into the commands required by the AOCS hardware.
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int actuate(AOCS_shell_configuration config) {
		// actuating the hardware with the algs cmds after conversion"
		hw_Manager.HMGR_Actuate(algs_interface.algs_tcmd);

		/* 
		 * Update the EWOD
		 */
		System.out.println("actuating the hardware with the algs cmds");
		//EWOD_Update();
		//all good
		return 0;
	}

	/**
	 * Check if the requested mode is a valid transition 
	 * @param newMode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Process_Shell.GDEF_STATUS CheckValidModetransition(AOCS_MODES newMode) {
		return AOCS_modeTransitionTable[AOCS_currentMode.ordinal()][newMode.ordinal()] ? GDEF_STATUS.GDEF_TRUE
				: GDEF_STATUS.GDEF_FALSE;
	}

	/**
	 * Constructor : create a state machine, used by AOCS_Shell
	  * 
	 */
	public AOCS_State_Machine() {
	}

	/**
	 * set shell (state machine) parameters after successful transition
	 */
	public void Set_Shell_AocsMode() {
		/* check if a mode transition */
		if (AOCS_reqMode != AOCS_currentMode) {
			/* update the mode */
			AOCS_currentMode = AOCS_reqMode;

			/* reset the ARO Counter */
			aro_Handler.ARO_Reset();

			/* hold off ARO during the mode transistion */
			aro_Handler.ARO_SetHoldOff(AOCS_currentMode);
		} else {

		}

		/* update the sample time */
		aocs_Configuration.ACON_SetRate(AOCS_currentMode.ordinal());

		/* set flags for algs*/

		/* signal to units the new mode */
		hw_Manager.HMGR_InitMode(AOCS_reqMode);

		/* set up sampling telemetry */
		//if (AMOH_isUnsolMode) {
		/* initialise the unsolicted telemetry */
		//UTLM_InitMode(AMOH_mode);
		//}

		/* update EWOD logging for mode */
		//EWOD_InitMode(AMOH_mode);
	}

	/**
	 * sets the safe mode flag (if no safe mode version exists of current mode then rejects)
	  * will also re-initialise a mode transition
	 * @param mode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Process_Shell.GDEF_STATUS AOCS_SafeModeTransition(AOCS_MODES mode) {
		/* set the safe state flag */
		if (AOCS_SetSafeMode(SAFE_MODES, mode) == GDEF_STATUS.GDEF_SUCCESS) {
			return GDEF_STATUS.GDEF_SUCCESS;
		}

		/* update the mode */
		AOCS_ForceMode(mode);

		return GDEF_STATUS.GDEF_SUCCESS;
	}

	/**
	 * if we set from OPS mode to safe mode then check that the current mode has a safe mode versio
	 * @param value 
	 * @param mode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Process_Shell.GDEF_STATUS AOCS_SetSafeMode(boolean value, AOCS_MODES mode) {
		// if we set from OPS mode to safe mode then check that the current mode has a safe mode version
		if (value == true) {
			if (NUM_SAFE_MODES[mode.ordinal()] == false)
				return GDEF_STATUS.GDEF_FAILURE;

		}

		AOCS_isSafeMode = value;

		//re-initialise the mode
		AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_REQ;

		return GDEF_STATUS.GDEF_SUCCESS;
	}

	/**
	 * Routine handle received pulse
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int pps_received(AOCS_shell_configuration config) {
		/*
		 * Synchronise the AOCS units every 60sec
		 */
		config.aocs_shell_pps_timer = System.currentTimeMillis();
		/*
		 * When we send timesync we need to send TC 5,1 to both AIMs again to tell to
		 * everyone that a new cycle starts now for everyone.
		 */
		/*
		 * stTcReqParams.psRegInfo = (tsCANS_RegRtn*)getCANReg();
		 * stTcReqParams.eSendQPriority = eCANS_LO_PRI_Q; stTcReqParams.eWait =
		 * eCANS_NO_WAIT; stTcReqParams.u1Src = CANADDR_ADCS_PROCESS;
		 * stTcReqParams.u4RetryCount = DEFAULT_AOCS_TC_RETRY_COUNT;
		 * stTcReqParams.u4RtnQIdx = DEFAULT_DISPATCHER_Q; stTcReqParams.u4Timeout =
		 * DEFAULT_TELECOMMAND_REQUEST_TIMEOUT;
		 */
		//send the TC
		AOCS_Process_Shell.aocs_TTC.CANA_send_tc(AOCS_Process_Shell.aocs_TTC.tcreqparams);

		No_of_PPS_sent++;
		/*
		 * Initialise parameters for a new cycle
		 */
		if (AOCS_DEFAULT_CYCLE_TIME <= No_of_PPS_sent) {
			// set the new event
			config.aocs_shell_fsm_event = AOCS_shell_fsm_event.ALL_PPS_RECEIVED;

			// set the time
			config.aocs_shell_event_action_time = System.currentTimeMillis();

			// process end execute the new event
			AOCS_Process_Shell.AOCS_Shell_deliver_event(config);

			// reset the counter
			No_of_PPS_sent = 0;
		}
		return 0;
	}

	/**
	 * Routine handle the case when all required PPS are received
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int all_pps_received(AOCS_shell_configuration config) {

		// set the new event
		config.aocs_shell_fsm_event = AOCS_State_Machine.AOCS_shell_fsm_event.AOCS_MESSAGE;

		// set the time
		config.aocs_shell_event_action_time = System.currentTimeMillis();

		// process end execute the new event
		AOCS_Process_Shell.AOCS_Shell_deliver_event(config);
		return 0;
	}

	/**
	 * Routine action Events into the AOCS Finite State Machine
	 * @param config Pointer to the AOCS Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static AOCS_Shell_EventHandler AOCS_Shell_process_event(AOCS_shell_configuration config) {
		/*
		 * The design intent is that the only method to execute Finite State Machine
		 * Event Handling Routine's is through this Finite State Machine Event Handler
		 */
		AOCS_Shell_EventHandler return_EventHandler = null;
		/*
		 * Add an entry into the AOCS Shell Process Log.
		 */
		System.out
				.println("Entered Function [" + config.aocs_shell_fsm_state + "][" + config.aocs_shell_fsm_event + "]");
		/*
		 * AOCS Protection Mutex Strategy:
		 * 
		 * We will obtain the AOCS Protection Mutex at this point.
		 */
		synchronized (config.aocs_shell_protection_mutex) {

			/*
			 * save the current state before moving to the next, this is done to know what
			 * action is next
			 */
			AOCS_shell_fsm_state current_state = config.aocs_shell_fsm_state;

			/*
			 * Move to the new state
			 */
			config.aocs_shell_fsm_state = AOCS_shell_state_table[config.aocs_shell_fsm_event
					.ordinal()][config.aocs_shell_fsm_state.ordinal()];

			/*
			 * Perform the next required Event
			 */
			if (AOCS_shell_event_table[config.aocs_shell_fsm_event.ordinal()][current_state.ordinal()] != null) {
				return_EventHandler = AOCS_shell_event_table[config.aocs_shell_fsm_event.ordinal()][current_state
						.ordinal()];
			} else {
				/*
				 * If an event has a null handler, it is a "can't happen" event, therefore, log
				 * a message
				 */

				/*
				 * Add an entry into the AOCS Shell Process Log.
				 */
				System.out.println("Invalid STATE: " + current_state + " EVENT: " + config.aocs_shell_fsm_event);
			}
			/*
			* Release the AOCS Shell Protection Mutex.
			*/
		}
		/*
		 * RETURN
		 */
		return return_EventHandler;
	}
}
