// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package AOCS_RTP;

// Manual imports
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import AOCS_RTP.AOCS_State_Machine.AOCS_MODES;
// End of manual imports

/************************************************************/
/**
 * Entry point for the OBC750 AOCS Process
 */
public class AOCS_Process_Shell {
	/**
	 * 
	 */
	public enum GDEF_STATUS {
		/**
		 * Failure
		 */
		GDEF_FAILURE,
		/**
		 * Success
		 */
		GDEF_SUCCESS,
		/**
		 * False
		 */
		GDEF_FALSE,
		/**
		 * True
		 */
		GDEF_TRUE;
	};

	/**
	 * 
	 */
	public enum AOCS_message_type {
		/**
		 * 
		 */
		eAOCSTimerMessage,
		/**
		 * 
		 */
		ePPSTimerMessage,
		/**
		 * 
		 */
		eActuationTimerMessage,
		/**
		 * 
		 */
		eAimCheckTimerMessage,
		/**
		 * 
		 */
		eAOCSLocalCanCmd,
		/**
		 * 
		 */
		eAOCSRegistrationMessage,
		/**
		 * 
		 */
		eAOCSProcessTerminating;
	};

	/**
	 * 
	 */
	public class AOCS_message_data {
		/**
		 * Message Index 
		 */
		public AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration message_pointer;
		/**
		 * Internal CAN Message 
		 */
		public int TcTlmNodeValue;
		/**
		 * AOCS Interface Registation Message Queue Name
		 */
		public int aocs_interface_message_queue_nam;
	};

	/**
	 * 
	 */
	public class AOCS_message {
		/**
		 * AOCS Message Type  
		 */
		public AOCS_message_type aocs_message_type;
		/**
		 * AOCS Message Data 
		 */
		public AOCS_message_data aocs_message_data;
		/**
		 * Process Identifier 
		 */
		public int obc750_process_identifie;
	};

	/**
	 * 
	 */
	public static AOCS_State_Machine aocs_State_Machine;
	/**
	 * 
	 */
	public static AOCS_TTC aocs_TTC;
	/**
	 * 
	 */
	public static AOCS_message _aocs_message;
	/**
	 *  Routine to handle the Message Interface implemented as a POSIX Thread
	 */
	public static Thread aocs_message_dispatcher_thread = new Thread() {
		public void run() {
			/*
			 * Initialise the AOCS Shell Protection Mutex. Thread is just an token, it could
			 * be any object
			*/
			_config.aocs_shell_protection_mutex = new Thread();
			/*
			 * We have 3 timers :
			 * PPSTimer
			 * ActuationTimer
			 * AIMCheckTimer (opt)
			 * */

			/*
			 * Create the AOCS PPS Timer.
			 */
			_config.aocs_shell_pps_timer_id = Executors.newSingleThreadScheduledExecutor(); // new Timer();
			/*
			* Connect the AOCS PPS Timer.
			* 			
			 * Schedule the task to run periodically every 'aocs_shell_pps_timer' milliseconds
			 * set the task and the timer value
			 */
			_config.aocs_shell_pps_timer_id.scheduleAtFixedRate(() -> aocs_pps_timer_signal_handler(_config), 0,
					_config.aocs_shell_pps_timer, TimeUnit.MILLISECONDS);

			/*
			 * Create the AOCS Actuation Timer.
			 */
			_config.aocs_shell_actuation_timer_id = Executors.newSingleThreadScheduledExecutor(); // new Timer();
			/*
			* Connect the AOCS Actuation Timer.
			* 			
			 * Schedule the task to run periodically every 'aocs_shell_actuation_timer' milliseconds
			 * set the task and the timer value
			 */
			/*
			 * wait 500 millisecond before starting the second timers
			 * according to the Figure 3 2: AOCS periodic activities (FSM) in the flight software specification
			 * */
			_config.aocs_shell_actuation_timer_id.scheduleAtFixedRate(
					() -> aocs_actuation_timer_signal_handler(_config), 500, _config.aocs_shell_actuation_timer,
					TimeUnit.MILLISECONDS);

			/*
			 * Create the AIM Check Timer.
			 */
			_config.aocs_shell_aim_check_timer_id = Executors.newSingleThreadScheduledExecutor(); // new Timer();
			/*
			* Connect the AOCS Actuation Timer.
			* 			
			 * Schedule the task to run periodically every 'aocs_shell_actuation_timer' milliseconds
			 * set the task and the timer value
			 */
			_config.aocs_shell_aim_check_timer_id.scheduleAtFixedRate(
					() -> aocs_aim_check_timer_signal_handler(_config), 500, _config.aocs_shell_aim_check_timer,
					TimeUnit.MILLISECONDS);

			/*
			 * Repeatedly read messages received on the AOCS Dispatcher Message Queue
			 */
			while (true) {
				while (_aocs_message == null) { // Check if message is available
					try {
						synchronized (this) { // Synchronize on the current object
							wait(); // Release lock and wait to be notified
						}
					} catch (InterruptedException e) {
						// Handle interruption (optional)
					}
				}
				/*
				 * Process the received message
				 */
				switch (_aocs_message.aocs_message_type) {
				/* The above 3 timers will send ticks message as followings :
				 * PPSTimer = ePPSTimerMessage (event = PPS_RECEIVED)
				 * ActuationTimer = eActuationTimerMessage (event = ACTUATE)
				 * AIMCheckTimer = eAimCheckTimerMessage
				 * the 'eAOCSTimerMessage' is set in 'aocs_shell_deliver_event' which is triggered between 
				 * Idle events: 'pps_received -> all_pps_received '(event = ALL_PPS_RECEIVED)  
				 * and 'all_pps_received -> run_AOCS' (event = AOCS_MESSAGE)
				 * to get back HERE and execute the Events into the AOCS Finite State Machine Table
				 */
				case eAOCSTimerMessage: {
					//get the aocs shell configuration struct from the message
					_config = _aocs_message.aocs_message_data.message_pointer;

					//Execute the Action related to Events (using the table) into the AOCS Finite State Machine
					AOCS_State_Machine.AOCS_Shell_process_event(_config).handleEvent(_config);

					break;
				}

				//PPS_RECEIVED event
				case ePPSTimerMessage: {
					/*
					 * Obtain the AOCS Shell Protection Mutex.
					 */
					synchronized (_config.aocs_shell_protection_mutex) {
						// set the event to know what to do next
						_config.aocs_shell_fsm_event = AOCS_State_Machine.AOCS_shell_fsm_event.PPS_RECEIVED;
						// get current time
						_config.aocs_shell_event_action_time = System.currentTimeMillis();
						// deliver the event to execute it
						AOCS_Shell_deliver_event(_config);
					}
					/*
					 * Release the AOCS Shell Protection Mutex.
					 */
					break;
				}
				case eActuationTimerMessage:
					/*
					 * Obtain the AOCS Shell Protection Mutex.
					 */
					synchronized (_config.aocs_shell_protection_mutex) {
						// set the event to know what to do next
						_config.aocs_shell_fsm_event = AOCS_State_Machine.AOCS_shell_fsm_event.ACTUATE;
						// get current time
						_config.aocs_shell_event_action_time = System.currentTimeMillis();
						// deliver the event to execute it
						AOCS_Shell_deliver_event(_config);
					}
					/*
					 * Release the AOCS Shell Protection Mutex.
					 */
					break;

				case eAimCheckTimerMessage:
					/*
					* Send sync cmds only if we are not SBM of SAFE
					*/
					break;
				default:
					System.out.println("Unknown Message received\n");
					break;

				}
				_aocs_message = null; // Reset message for next iteration
			}
		}
	};
	/**
	 * 
	 */
	public static AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration _config;
	/**
	 * Routine to register the AOCS Process with the CAN Server.
	  * Registers Telecommand and Telemetry service queues and a generic receive message queue.
	  * Block waits for Received CAN messages.
	 */
	public Thread aocs_can_thread;

	/**
	 * Routine to generate the telemetry information that will be transmitted on the downlink.
	 */
	public void AOCS_downlink_telemetry_handler() {
	}

	/**
	 * Routine to the CAN API Registration Structure
	 */
	public void getCANReg() {
	}

	/**
	 * Routine to handle the PPS Timer Signal
	 * @param config 
	 */
	public static void aocs_pps_timer_signal_handler(AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
		/*set the message type to ePPSTimerMessage to process in the message loop of the aocs_message_dispatcher_thread
		*the other types are set the three timers (actuation, deliver_event, aim )
		*/
		_aocs_message.aocs_message_type = AOCS_message_type.ePPSTimerMessage;

		//get the aocs shell configuration
		_aocs_message.aocs_message_data.message_pointer = config;

		/*
		 * Send the message to the AOCS Process Dispatcher.
		 */
		//mq_send(config); this hat was done

		//wake up the message waiting thread
		aocs_message_dispatcher_thread.notify();
	}

	/**
	 * Routine to handle the Actuation Timer Signal
	 * @param config 
	 */
	public static void aocs_actuation_timer_signal_handler(
			AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
		/*set the message type to eActuationTimerMessage to process in the message loop of the aocs_message_dispatcher_thread
		*the other types are set the three timers (pps, deliver_event, aim )
		*/
		_aocs_message.aocs_message_type = AOCS_message_type.eActuationTimerMessage;

		//get the aocs shell configuration
		_aocs_message.aocs_message_data.message_pointer = config;

		/*
		 * Send the message to the AOCS Process Dispatcher.
		 */
		//mq_send(config); this hat was done

		//wake up the message waiting thread
		aocs_message_dispatcher_thread.notify();
	}

	/**
	 * Routine to handle the AIM Check Timer Signal
	 * @param config 
	 */
	public static void aocs_aim_check_timer_signal_handler(
			AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
		/*set the message type to eAimCheckTimerMessage to process in the message loop of the aocs_message_dispatcher_thread
		*the other types are set the three timers (pps, deliver_event, actuation)
		*/
		_aocs_message.aocs_message_type = AOCS_message_type.eAimCheckTimerMessage;

		//get the aocs shell configuration
		_aocs_message.aocs_message_data.message_pointer = config;

		/*
		 * Send the message to the AOCS Process Dispatcher.
		 */
		//mq_send(config); this hat was done

		//wake up the message waiting thread
		aocs_message_dispatcher_thread.notify();
	}

	/**
	 * Entry point for the OBC750 AOCS Process
	 * @param arg 
	 * @param argv 
	 */
	public void main(int arg, String argv) {
		/*
		*  Create the AOCS CAN Thread.
		*/
		aocs_can_thread.start();
		/*
		* Create the AOCS Message Dispatcher Thread.
		*/
		aocs_message_dispatcher_thread.start();

		/* Initialise the task */
		TaskInit();

		/*
		 * Register with the Downlink Telemetry Handler
		 */
		AOCS_downlink_telemetry_handler();
		//TODO : add the drive file functionality
		//TODO : Register with the SKED library
	}

	/**
	 * AOCS Task exit function
	 */
	public void TaskExit() {
	}

	/**
	 * AOCS Task initialisation function
	 */
	public void TaskInit() {
		System.out.println("AOCS Process Started\n");

		/* ensure mode is in standby */
		aocs_State_Machine.AOCS_ForceMode(AOCS_MODES.SBM);

		/* initialise telemetry */
		aocs_TTC.ATTC_Init();

		/* initialise AOCS variables etc. */
		aocs_State_Machine.algs_interface.AINT_Init();
	}

	/**
	 * Initialises a new AOCS cycle
	  * Initialise data gathering for new cycle
	  * 
	 */
	public static void InitAocs() {
	}

	/**
	 * Routine to deliver an EVENT to the AOCS Finite State Machine.
	 * @param config Pointer to the AOCS Configuration Structure
	 */
	public static void AOCS_Shell_deliver_event(AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
		/*
		 * Obtain the AOCS Shell Protection Mutex.
		 */
		synchronized (config.aocs_shell_protection_mutex) {

			// set the message type to eAOCSTimerMessage to process in the following message in the first case
			//the other types are set the three timers (actuation, pps, aim )
			_aocs_message.aocs_message_type = AOCS_message_type.eAOCSTimerMessage;

			//get the aocs shell configuration
			_aocs_message.aocs_message_data.message_pointer = config;

			/*
			 * Send the message to the AOCS Process Dispatcher.
			 */
			//mq_send(config); this hat was done

			//wake up the message waiting thread
			aocs_message_dispatcher_thread.notify();

		}
		/*
		 * Release the AOCS Shell Protection Mutex.
		 */
	}
}
