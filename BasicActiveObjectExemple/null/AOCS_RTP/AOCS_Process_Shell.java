// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package AOCS_RTP;

/************************************************************/
/**
 * Entry point for the OBC750 AOCS Process
 */
public class AOCS_Process_Shell {
	/**
	 * 
	 */
	public enum GDEF_STATUS {
		/**
		 * Failure
		 */
		GDEF_FAILURE,
		/**
		 * Success
		 */
		GDEF_SUCCESS,
		/**
		 * False
		 */
		GDEF_FALSE,
		/**
		 * True
		 */
		GDEF_TRUE;
	};

	/**
	 * 
	 */
	public enum AOCS_message_type {
		/**
		 * 
		 */
		eAOCSTimerMessage,
		/**
		 * 
		 */
		ePPSTimerMessage,
		/**
		 * 
		 */
		eActuationTimerMessage,
		/**
		 * 
		 */
		eAimCheckTimerMessage,
		/**
		 * 
		 */
		eAOCSLocalCanCmd,
		/**
		 * 
		 */
		eAOCSRegistrationMessage,
		/**
		 * 
		 */
		eAOCSProcessTerminating;
	};

	/**
	 * 
	 */
	public class AOCS_message_data {
		/**
		 * Message Index 
		 */
		public AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration message_pointer;
		/**
		 * Internal CAN Message 
		 */
		public int TcTlmNodeValue;
		/**
		 * AOCS Interface Registation Message Queue Name
		 */
		public int aocs_interface_message_queue_nam;
	};

	/**
	 * 
	 */
	public class AOCS_message {
		/**
		 * AOCS Message Type  
		 */
		public AOCS_message_type aocs_message_type;
		/**
		 * AOCS Message Data 
		 */
		public AOCS_message_data aocs_message_data;
		/**
		 * Process Identifier 
		 */
		public int obc750_process_identifie;
	};

	/**
	 * 
	 */
	public class TcReqParams {
		/**
		 * 
		 */
		public byte psRegInfo;
		/**
		 * 
		 */
		public int eSendQPriority;
		/**
		 * 
		 */
		public int eWait;
		/**
		 * source CAN ADDR
		 */
		public int u1Src;
		/**
		 * DEFAULT_TC_RETRY_COUNT
		 */
		public int u4RetryCount;
		/**
		 * DEFAULT_DISPATCHER_Q
		 */
		public int u4RtnQIdx;
		/**
		 * DEFAULT_TELECOMMAND_REQUEST_TIMEOUT
		 */
		public int u4Timeout;
	};

	/**
	 * 
	 */
	public static AOCS_State_Machine aocs_State_Machine;
	/**
	 * 
	 */
	public static AOCS_TTC aocs_TTC;
	/**
	 * 
	 */
	public static AOCS_message aocs_message;
	/**
	 * 
	 */
	public static TcReqParams tcreqparams;

	/**
	 * Routine to generate the telemetry information that will be transmitted on the downlink.
	 */
	public void AOCS_downlink_telemetry_handler() {
	}

	/**
	 * Routine to the CAN API Registration Structure
	 */
	public void getCANReg() {
	}

	/**
	 * Routine to handle the PPS Timer Signal
	 */
	public void aocs_pps_timer_signal_handler() {
	}

	/**
	 * Routine to handle the Actuation Timer Signal
	 */
	public void aocs_actuation_timer_signal_handler() {
	}

	/**
	 * Routine to handle the AIM Check Timer Signal
	 */
	public void aocs_aim_check_timer_signal_handler() {
	}

	/**
	 * Routine to handle the Message Interface implemented as a POSIX Thread.
	 * @param config 
	 */
	public void aocs_message_dispatcher_thread(AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
		/*
					 * Initialise the AOCS Shell Protection Mutex. Thread is just an token, it could
					 * be any object
					 */
		config.aocs_shell_protection_mutex = new Thread();
		/*
		 * Create the AOCS PPS Timer.
		 */
		config.aocs_shell_pps_timer_id = 0; // new Timer();
		/*
		 * Connect the AOCS Actuation Timer.
		 */
		config.aocs_shell_actuation_timer_id = 0; // new Timer();
		/*
		 * Repeatedly read messages received on the AOCS Dispatcher Message Queue
		 */
		for (;;) {
			/*
			 * Process the received message
			 */
			switch (aocs_message.aocs_message_type) {
			/*
			 * When a message is received from outside, it will never enter in this case at first
			 * it first get processed in the following cases
			 * then the AOCS_Shell_process_event to right EVENT
			 * and the aocs_message_type to 'eAOCSTimerMessage'
			 * to get back HERE and execute the Events into the AOCS Finite State Machine Table
			 */
			case eAOCSTimerMessage: {
				//get the aocs shell configuration struct from the message
				config = aocs_message.aocs_message_data.message_pointer;

				//Execute the Action related to Events (using the table) into the AOCS Finite State Machine
				AOCS_State_Machine.AOCS_Shell_process_event(config).handleEvent(config);

				break;
			}

			//PPS_RECEIVED event
			case ePPSTimerMessage: {
				/*
				 * Obtain the AOCS Shell Protection Mutex.
				 */
				synchronized (config.aocs_shell_protection_mutex) {
					// set the event to know what to do next
					config.aocs_shell_fsm_event = AOCS_State_Machine.AOCS_shell_fsm_event.PPS_RECEIVED;
					// get current time
					config.aocs_shell_event_action_time = System.currentTimeMillis();
					// deliver the event to execute it
					AOCS_Shell_deliver_event(config);
				}
				/*
				 * Release the AOCS Shell Protection Mutex.
				 */
				break;
			}
			case eActuationTimerMessage:
				/*
				 * Obtain the AOCS Shell Protection Mutex.
				 */
				synchronized (config.aocs_shell_protection_mutex) {
					// set the event to know what to do next
					config.aocs_shell_fsm_event = AOCS_State_Machine.AOCS_shell_fsm_event.ACTUATE;
					// get current time
					config.aocs_shell_event_action_time = System.currentTimeMillis();
					// deliver the event to execute it
					AOCS_Shell_deliver_event(config);
				}
				/*
				 * Release the AOCS Shell Protection Mutex.
				 */
				break;

			case eAimCheckTimerMessage:
				/*
				* Send sync cmds only if we are not SBM of SAFE
				*/
				break;
			default:
				System.out.println("Unknown Message received\n");
				break;

			}
		}
	}

	/**
	 * Entry point for the OBC750 AOCS Process
	 * @param arg 
	 * @param argv 
	 */
	public void main(int arg, String argv) {
	}

	/**
	 * AOCS Task exit function
	 */
	public void TaskExit() {
	}

	/**
	 * AOCS Task initialisation function
	 */
	public void TaskInit() {
	}

	/**
	 * Routine to register the AOCS Process with the CAN Server.
	  * Registers Telecommand and Telemetry service queues and a generic receive message queue.
	  * Block waits for Received CAN messages.
	 */
	public void aocs_can_thread() {
	}

	/**
	 * Initialises a new AOCS cycle
	 */
	public void InitAocs() {
	}

	/**
	 * Send can message
	  * 
	 * @param config Pointer to the AOCS Configuration Structure
	 */
	public static void mq_send(AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
	}

	/**
	 * Routine to deliver an EVENT to the AOCS Finite State Machine.
	 * @param config Pointer to the AOCS Configuration Structure
	 */
	public static void AOCS_Shell_deliver_event(AOCS_RTP.AOCS_State_Machine.AOCS_shell_configuration config) {
		/*
		 * Obtain the AOCS Shell Protection Mutex.
		 */
		synchronized (config.aocs_shell_protection_mutex) {

			// set the message type to eAOCSTimerMessage to process in the following message in the first case
			aocs_message.aocs_message_type = AOCS_message_type.eAOCSTimerMessage;

			//get the aocs shell configuration
			aocs_message.aocs_message_data.message_pointer = config;

			//send the CAN message
			mq_send(config);
		}
		/*
		 * Release the AOCS Shell Protection Mutex.
		 */
	}

	/**
	 * Send a CAN TC
	 * @param TcReqParams TC parameters data
	 */
	public static void CANA_send_tc(TcReqParams TcReqParams) {
	}
}
