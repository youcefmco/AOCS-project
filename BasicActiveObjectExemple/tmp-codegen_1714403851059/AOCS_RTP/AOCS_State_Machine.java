// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package AOCS_RTP;

import java.util.Map;

// Manual imports
import AOCS_RTP.AOCS_Shell.GDEF_STATUS;
import java.util.HashMap;
// End of manual imports

/************************************************************/
/**
 * 
 */
public class AOCS_State_Machine {
	/**
	 * 
	 */
	public enum AOCS_MODES {
		/**
		 * 
		 */
		SBM,
		/**
		 * 
		 */
		DTM,
		/**
		 * 
		 */
		YTM,
		/**
		 * 
		 */
		CPM,
		/**
		 * 
		 */
		NOM;
	};

	/**
	 * 
	 */
	public enum AOCS_TRANS_STATE {
		/**
		 * no transition occurring
		 */
		AMOH_TRANS_IDLE,
		/**
		 * transition requested 
		 */
		AMOH_TRANS_REQ,
		/**
		 * hardware configuration
		 */
		AMOH_TRANS_CONFIG,
		/**
		 * set shell parameters
		 */
		AMOH_TRANS_SHELL,
		/**
		 * set algorithm parameters
		 */
		AMOH_TRANS_ALGS;
	};

	/**
	 * This enum defines the possible states of the AOCS shell FSM
	 */
	public enum AOCS_shell_fsm_state {
		/**
		 * AOCS Shell Idle State 
		  * The inactive state where the shell awaits events
		 */
		IDLE,
		/**
		 * AOCS Shell All Pulses Received-check TLM State
		  * State where all Pulse Per Second (PPS) signals are received, and telemetry checks are likely performed
		 */
		TLMR,
		/**
		 * AOCS Shell Run AOCS cycle State
		  * State where the AOCS cycle is running
		 */
		RUNA;
	};

	/**
	 * This enum defines the events that can trigger state transitions in the FSM
	 */
	public enum AOCS_shell_fsm_event {
		/**
		 * Event triggered when a PPS signal is received
		 */
		PPS_RECEIVED,
		/**
		 * Event triggered when all expected PPS signals are received
		 */
		ALL_PPS_RECEIVED,
		/**
		 * Event triggered when a message from AOCS instructs the shell to start the AOCS cycle.
		 */
		AOCS_MESSAGE,
		/**
		 * Issue Actuate command Event
		 */
		ACTUATE;
	};

	/**
	 * 
	 */
	public class AOCS_shell_configuration {
		/**
		 * Firewall Pattern to help detect Memory Corruption
		 */
		public int firewall_head;
		/**
		 * AOCS Shell Protection Mutex 
		 */
		public Thread aocs_shell_protection_mutex;
		/**
		 * AOCS Shell FSM State   
		 */
		public AOCS_shell_fsm_state aocs_shell_fsm_state;
		/**
		 * AOCS Shell FSM Event
		 */
		public AOCS_shell_fsm_event aocs_shell_fsm_event;
		/**
		 * AOCS Shell FSM Event Action Time 
		 */
		public int aocs_shell_event_action_time;
	};

	/**
	 * Current mode
	 */
	private AOCS_MODES AOCS_currentMode = AOCS_MODES.SBM;
	/**
	 * store the requested mode before a transition
	 */
	private AOCS_MODES AOCS_reqMode;
	/**
	 * Store the transition state (if idle next mode)
	 */
	public AOCS_TRANS_STATE AOCS_transState;
	/**
	 * flag to indicate if this is a safe mode
	 */
	public boolean AOCS_isSafeMode;
	/**
	 * Set the requested mode if it is a valid transition
	 */
	public boolean[][] AOCS_modeTransitionTable = new boolean[][] {
			// SBM-----DTM---YTM----CPM----NOM-- : new/old
			{ false, true, false, false, false }, // SBM
			{ true, false, false, false, false }, // DTM
			{ false, false, false, true, false }, // YTM
			{ false, false, false, false, true }, // CPM
			{ false, false, false, false, false } // NOM
	};
	/**
	 * 
	 */
	private StateThread statethread;
	/**
	 * 
	 */
	public static Map<AOCS_MODES, Integer> modeIndexMap = new HashMap<>() {
		{
			put(AOCS_MODES.SBM, 0);
			put(AOCS_MODES.DTM, 1);
			put(AOCS_MODES.YTM, 2);
			put(AOCS_MODES.CPM, 3);
			put(AOCS_MODES.NOM, 4);
		}
	};
	/**
	 * return the AOCS period
	 */
	public int AOCS_maxCycle;
	/**
	 * 
	 */
	public static ALGS_Interface algs_interface;
	/**
	 * 
	 */
	public boolean AOCS_isUnsolMode;
	/**
	 * 
	 */
	public static HW_Manager hw_Manager;
	/**
	 * 
	 */
	public ARO_Handler aro_Handler;
	/**
	 * 
	 */
	public AOCS_Configuration aocs_Configuration;
	/**
	 * Tells is that the current mode has a safe mode version 
	 */
	public boolean[] NUM_SAFE_MODES;
	/**
	 * Tell if we have safe modes for each one of the AOCS modes
	 */
	public boolean SAFE_MODES = false;
	/**
	 * This 2D array defines the next state for each combination of event and current state. 
	  *     * Rows represent events (e.g., PPS_RECEIVED).
	  *     * Columns represent current states (e.g., IDLE).
	 */
	public AOCS_shell_fsm_state[][] AOCS_shell_state_table = new AOCS_shell_fsm_state[][] {
			/*
			 * RUNAOCS -----------------------------------------------------------------
			 * CHECKTLM ----------------------------------------      					|
			 * IDLE-----------------     		  				|      					|
			 *                      |        	  				|						|
			 *                      |     		  				|     					|
			 */
			{ AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE }, // PPS_RECEIVED    
			{ AOCS_shell_fsm_state.TLMR, AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE }, //ALL_PPS_RECEIVED 
			{ AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.RUNA, AOCS_shell_fsm_state.IDLE }, // ADCS_MESSAGE 
			{ AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE, AOCS_shell_fsm_state.IDLE }// ACTUATE
	};
	/**
	 * This 2D array defines functions associated with each event-state combination. Similar to the state transition table:
	  *     * Rows represent events.
	  *     * Columns represent current states.
	 */
	public AocsShellEventHandler[][] AOCS_shell_event_table = new AocsShellEventHandler[][] {
			/*
			 * RUNAOCS -----------------------------------------------------------------
			 * CHECKTLM ----------------------------------------      					|
			 * IDLE-----------------     		  				|      					|
			 *                      |        	  				|						|
			 *                      |     		  				|     					|
			 */
			{ AOCS_State_Machine::pps_received, null, null }, /* PPS_RECEIVED           */
			{ AOCS_State_Machine::all_pps_received, null, null }, /* ALL_PPS_RECEIVED       */
			{ null, AOCS_State_Machine::run_AOCS, null }, /* ADCS_MESSAGE           */
			{ null, null, AOCS_State_Machine::actuate }/* ACTUATE                */
	};
	/**
	 * 
	 */
	public int aaaa;

	/**
	 * check if the mode transition is valid then start the updateMode transitions routine
	 * @param newMode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Shell.GDEF_STATUS AOCS_RequestMode(AOCS_MODES newMode) {
		/* check if already performing a mode transistion */
		if (AOCS_transState != AOCS_TRANS_STATE.AMOH_TRANS_IDLE) {
			System.out
					.println("Unable to process mode trans req: [" + AOCS_currentMode + "] -> [" + AOCS_reqMode + "]");
			return GDEF_STATUS.GDEF_FAILURE;
		}
		/* check if is different to current value */
		if (newMode != AOCS_currentMode) {
			/* Set the requested mode if it is a valid transistion */
			if (GDEF_STATUS.GDEF_TRUE == CheckValidModetransition(newMode)) {

				/* set the request mode */
				AOCS_reqMode = newMode;

				/* set the transition state to requested */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_REQ;

				// AOCS Algs will see the flag change and proceeds with mode transition
				AOCS_UpdateMode();
				// print into the ewod
				System.out.println("VALID mode trans req: [" + AOCS_currentMode + "] -> [" + AOCS_reqMode + "]");
			}
		}
		return GDEF_STATUS.GDEF_SUCCESS;
	}

	/**
	 * sets the mode regardless of requests or valid transitions
	 * @param newMode 
	 */
	public void AOCS_ForceMode(AOCS_MODES newMode) {
		/* if current mode transition occurring then abort */
		// ACON_AbortSked(); // not in our case

		// print into the ewod
		System.out.println("Force Mode change to" + AOCS_reqMode);

		//other mode so update in usual manner
		AOCS_reqMode = newMode;
		AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_REQ;
		AOCS_UpdateMode();
	}

	/**
	 * Allow a mode change for new cycle
	 */
	public void AOCS_UpdateMode() {
		// switch the current transition state
		switch (AOCS_transState) {
		case AMOH_TRANS_IDLE:
			/* nothing to do so just return */
			break;

		case AMOH_TRANS_REQ: {
			/*
			 * no config required in standby OPS, config might be required in safe standby
			 * (i.e. logging telemetry)
			 */
			if ((AOCS_MODES.SBM == AOCS_reqMode) && (AOCS_isSafeMode == false)) {
				// update ewod
				// EWOD_SetDefaultTlmType(MODE_SBM);
				/* standby mode so just update shell params */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_SHELL;
			} else {
				/* kick off the hardware config sked for the mode */
				if (GDEF_STATUS.GDEF_SUCCESS != aocs_Configuration.ACON_StartSked(modeIndexMap.get(AOCS_reqMode))) {
					// failure
					/* abort and go Back */
					AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_IDLE;
					// log to ewod
					System.out.println("Unable to run config sked for mode [" + AOCS_reqMode + "]");
				} else {
					// success
					/* update state to config */
					AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_CONFIG;
					// log to ewod
					System.out.println("config started for mode [" + AOCS_reqMode + "]");
				}
			}
			break;

		}
		case AMOH_TRANS_CONFIG: {
			// check configuration sked complete
			if (!aocs_Configuration.ACON_GetSkedStatus()) {
				// log to ewod
				System.out.println("Config sked completed for mode [" + AOCS_reqMode + "]");
				/* update state to shell */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_SHELL;
			}
			break;
		}
		case AMOH_TRANS_SHELL: {
			/* set shell parameters */
			Set_Shell_AocsMode();

			/* set init flag for algs */
			algs_interface.algs_Struct.mode_isReset = true;
			algs_interface.algs_Struct.mode_current = AOCS_currentMode;
			algs_interface.algs_Struct.mode_isSafeMode = AOCS_isSafeMode;
			algs_interface.algs_Struct.mode_isUnsolicited = AOCS_isUnsolMode;

			// log to ewod
			System.out.println("Shell updated to mode [" + AOCS_reqMode + "]");

			/* update state to ALGS */
			AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_ALGS;
			/* fall through to trans algs immediately */
			break;
		}
		case AMOH_TRANS_ALGS: {

			if (algs_interface.algs_Struct.mode_isReset == false) {
				// log to ewod
				System.out.println("Transition completed to mode [" + AOCS_reqMode + "]");

				/* update state to idle */
				AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_IDLE;
			}

			break;
		}
		default: {
			/* Invalid trans state*/
			System.out.println("Invalid trans state [" + AOCS_reqMode + "]");

			/* update state to idle */
			AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_IDLE;
			break;
		}

		}
	}

	/**
	 * get requested mode number
	 * @return 
	 */
	public AOCS_MODES AOCS_GetReqMode() {
		return AOCS_reqMode;
	}

	/**
	 * Sets the AOCS period
	 * @param period 
	 */
	public void AOCS_SetPeriod(int period) {
		AOCS_maxCycle = period;
	}

	/**
	 *  Calls the AOCS function, checks for errors, and implements the ARO counter.
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int run_AOCS(AOCS_shell_configuration config) {
		//all good
		return 0;
	}

	/**
	 *  Sends the commands to the actuators and updates the AOCS ewods. (HMGR_Actuate)
	  * This function converts the data provided by the AOCS algorithms  into the commands required by the AOCS hardware.
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int actuate(AOCS_shell_configuration config) {
		// actuating the hardware with the algs cmds after conversion"
		hw_Manager.HMGR_Actuate(algs_interface.algs_tcmd);

		/* 
		 * Update the EWOD
		 */
		System.out.println("actuating the hardware with the algs cmds");
		//EWOD_Update();
		//all good
		return 0;
	}

	/**
	 * Check if the requested mode is a valid transition 
	 * @param newMode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Shell.GDEF_STATUS CheckValidModetransition(AOCS_MODES newMode) {
		return AOCS_modeTransitionTable[modeIndexMap.get(AOCS_currentMode)][modeIndexMap.get(newMode)]
				? GDEF_STATUS.GDEF_TRUE
				: GDEF_STATUS.GDEF_FALSE;
	}

	/**
	 * Constructor : create a state machine, used by AOCS_Shell
	  * 
	 */
	public AOCS_State_Machine() {
	}

	/**
	 * set shell (state machine) parameters after successful transition
	 */
	public void Set_Shell_AocsMode() {
		/* check if a mode transition */
		if (AOCS_reqMode != AOCS_currentMode) {
			/* update the mode */
			AOCS_currentMode = AOCS_reqMode;

			/* reset the ARO Counter */
			aro_Handler.ARO_Reset();

			/* hold off ARO during the mode transistion */
			aro_Handler.ARO_SetHoldOff(AOCS_currentMode);
		} else {

		}

		/* update the sample time */
		aocs_Configuration.ACON_SetRate(AOCS_State_Machine.modeIndexMap.get(AOCS_currentMode));

		/* set flags for algs*/

		/* signal to units the new mode */
		hw_Manager.HMGR_InitMode(AOCS_reqMode);

		/* set up sampling telemetry */
		//if (AMOH_isUnsolMode) {
		/* initialise the unsolicted telemetry */
		//UTLM_InitMode(AMOH_mode);
		//}

		/* update EWOD logging for mode */
		//EWOD_InitMode(AMOH_mode);
	}

	/**
	 * sets the safe mode flag (if no safe mode version exists of current mode then rejects)
	  * will also re-initialise a mode transition
	 * @param mode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Shell.GDEF_STATUS AOCS_SafeModeTransition(AOCS_MODES mode) {
		/* set the safe state flag */
		if (AOCS_SetSafeMode(SAFE_MODES, mode) == AOCS_Shell.GDEF_STATUS.GDEF_SUCCESS) {
			return AOCS_Shell.GDEF_STATUS.GDEF_SUCCESS;
		}

		/* update the mode */
		AOCS_ForceMode(mode);

		return AOCS_Shell.GDEF_STATUS.GDEF_SUCCESS;
	}

	/**
	 * if we set from OPS mode to safe mode then check that the current mode has a safe mode versio
	 * @param value 
	 * @param mode 
	 * @return 
	 */
	public AOCS_RTP.AOCS_Shell.GDEF_STATUS AOCS_SetSafeMode(boolean value, AOCS_MODES mode) {
		// if we set from OPS mode to safe mode then check that the current mode has a safe mode version
		if (value == true) {
			if (NUM_SAFE_MODES[AOCS_State_Machine.modeIndexMap.get(mode)] == false)
				return AOCS_Shell.GDEF_STATUS.GDEF_FAILURE;

		}

		AOCS_isSafeMode = value;

		//re-initialise the mode
		AOCS_transState = AOCS_TRANS_STATE.AMOH_TRANS_REQ;

		return AOCS_Shell.GDEF_STATUS.GDEF_SUCCESS;
	}

	/**
	 * Routine handle received pulse
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int pps_received(AOCS_shell_configuration config) {
		//all good
		return 0;
	}

	/**
	 * Routine handle the case when all required PPS are received
	 * @param config Pointer to the AOCS shell Configuration Structure
	 * @return Success / Failure Indication
	 */
	public static int all_pps_received(AOCS_shell_configuration config) {
		//all good
		return 0;
	}
}
